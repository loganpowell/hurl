{"id":"node_modules/@thi.ng/transducers/func/compr.js","dependencies":[{"name":"C:\\Users\\logan\\Projects\\thi-ng\\hurl\\package.json","includedInParent":true,"mtime":1575488721738},{"name":"C:\\Users\\logan\\Projects\\thi-ng\\hurl\\node_modules\\@thi.ng\\transducers\\package.json","includedInParent":true,"mtime":1575409828371}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compR = void 0;\n\n/**\n * Reducer composition helper. Takes existing reducer `rfn` (a 3-tuple)\n * and a reducing function `fn`. Returns a new reducer tuple of this\n * form:\n *\n * ```\n * [rfn[0], rfn[1], fn]\n * ```\n *\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @param rfn\n * @param fn\n */\nconst compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n\nexports.compR = compR;"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":8,"column":0},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":1,"column":0}},{"generated":{"line":29,"column":0},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":7}},{"name":"compR","generated":{"line":29,"column":6},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":13}},{"generated":{"line":29,"column":11},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":18}},{"generated":{"line":29,"column":14},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":21}},{"name":"rfn","generated":{"line":29,"column":15},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":22}},{"generated":{"line":29,"column":18},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":21}},{"name":"fn","generated":{"line":29,"column":20},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":27}},{"generated":{"line":29,"column":22},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":21}},{"generated":{"line":29,"column":27},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":34}},{"name":"rfn","generated":{"line":29,"column":28},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":35}},{"generated":{"line":29,"column":31},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":38}},{"generated":{"line":29,"column":32},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":39}},{"generated":{"line":29,"column":33},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":38}},{"generated":{"line":29,"column":34},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":34}},{"name":"rfn","generated":{"line":29,"column":36},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":43}},{"generated":{"line":29,"column":39},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":46}},{"generated":{"line":29,"column":40},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":47}},{"generated":{"line":29,"column":41},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":46}},{"generated":{"line":29,"column":42},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":34}},{"name":"fn","generated":{"line":29,"column":44},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":51}},{"generated":{"line":29,"column":46},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":34}},{"generated":{"line":29,"column":47},"source":"node_modules/@thi.ng/transducers/func/compr.js","original":{"line":22,"column":7}}],"sources":{"node_modules/@thi.ng/transducers/func/compr.js":"/**\n * Reducer composition helper. Takes existing reducer `rfn` (a 3-tuple)\n * and a reducing function `fn`. Returns a new reducer tuple of this\n * form:\n *\n * ```\n * [rfn[0], rfn[1], fn]\n * ```\n *\n * `rfn[2]` reduces values of type `B` into an accumulator of type `A`.\n * `fn` accepts values of type `C` and produces interim results of type\n * `B`, which are then (possibly) passed to the \"inner\" `rfn[2]`\n * function. Therefore the resulting reducer takes inputs of `C` and an\n * accumulator of type `A`.\n *\n * It is assumed that `fn` internally calls `rfn[2]` to pass its own\n * results for further processing by the nested reducer `rfn`.\n *\n * @param rfn\n * @param fn\n */\nexport const compR = (rfn, fn) => [rfn[0], rfn[1], fn];\n"},"lineCount":null}},"error":null,"hash":"34db187b0ae87be1f988d2c1aef3f0ae","cacheData":{"env":{}}}